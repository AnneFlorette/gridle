// |------------------------------------------------------
// |------------------------------------------------------
// | Functions
// |------------------------------------------------------
// |------------------------------------------------------


/**
 * Map set
 *
 * @param 	Map 	$map 		The map to use
 * @param 	String 	$key 		The key to update
 * @param 	Mixed 	$value 		The new value
 * @return 	Map 			The new map
 */
@function map-set($map, $key, $value) {
	$new: ($key: $value);
	@return map-merge($map, $new);
}


/**
 * Get the column width in percent for the global or a specific context
 *
 * @param 	int 		$columns 					The number of columns to calculate
 * @param 	int 		$context : $gridle-columns-count 	 	The context to use
 * @return 	percentage 							The width in percent
 */
@function gridle_get_columns_width(
	$columns : 1,
	$context : $gridle-columns-count
) {
	@return percentage(1 / $context * $columns);
}
@function gridle_get_column_width(
	$columns : 1,
	$context : $gridle-columns-count
) { 
	@return gridle_get_columns_width($columns, $context);
}


/**
 *  Get a state map
 */
@function _gridle_get_state(
	$name
) {
	// if name if not a string, return null :
	@if type-of($name) != string
	{
		@return false;
	}

	// check if has a state named like this :
	@if (map-has-key($_gridle_states, $name))
	{
		@return map-get($_gridle_states, unquote($name));
	} 

	@return false;
}


/**
 * Get the media queries variables :
 *
 * @param 	int 		$index 	 	The media query indes
 * @param 	String 		$var 		The media query variable name
 * @return 	String|int 			The variable value
 */
@function _gridle_get_state_var(
	$stateName,
	$var 	: "name"
) {

	// get the state :
	$state : _gridle_get_state($stateName);

	// check ig state and if has the variable :
	@if $state
	      and map-has-key($state,unquote($var))
	{
		@return map-get($state,unquote($var));
	}

	// nothing getted :
	@return null;
}


/**
 * Set a variable in a state
 * @param 	Mixed $stateName-or-stateIndex 	The state name of state index
 * @param  	String $var                    		Variable name to assign
 * @param  	Mixed $newValue          		The new value to assign
 * @return 	List                         			The states list (full)
 */
@function _gridle_set_state_var(
	$stateName,
	$var,
	$newValue
) {
	// get the state :
	$state : _gridle_get_state($stateName);

	// check ig state and if has the variable :
	@if $state
	      and map-has-key($state,unquote($var))
	{
		// set new value in state :
		$state : map-set($state, unquote($var), $newValue);

		// set states :
		$_gridle_states : map-set($_gridle_states, unquote($stateName), $state);

		// return new state :
		@return $state;
	}

	// nothing getted :
	@return null;
}


/**
 * Generate a column
 *
 * @param 	String 		$name 			The column name (often count)
 * @param 	int 		$columns 		The column count that the column will take
 * @param 	int 		$context 		The context on witch the with will be calculed
 * @param 	Boolean 	$generateClasses 	Set if the column has to be generated in css
 */
@function _gridle_create_column(
	$name,
	$columns,
	$context,
	$generateClasses : true
) {
	@return (
		name : $name,
		columns : $columns,
		context : $context,
		generateClasses : $generateClasses
	);
}


/**
 * Generate classname
 *
 * @param 	List 		$parrern 	The pattern to use to generate classname
 * @param 	String 		$state 		The state
 * @param 	int 		$count 		The column count
 */
@function _gridle_classname(
	$pattern,
	$state : null,
	$count : null
) {

	// init selector :
	$sel : ".";

	// add class prefix :
	@if $gridle-class-prefix and $gridle-class-prefix != '' {
		$sel : "#{$sel}#{$gridle-class-prefix}";
		@if $gridle-class-separator {
			$sel : "#{$sel}#{$gridle-class-separator}";
		}
	}

	// construct class name :
	$i : 1;
	@each $var in $pattern {
		
		// replace tokens :
		@if $var == '%state' and $state {
			$sel : "#{$sel}#{$state}";
		} 
		@if $var == '%count' and $count {
			$sel : "#{$sel}#{$count}";
		}  
		@if $var != '%state' and $var != '%count' and $var != '%-' and $var != '%prefix' {
			$sel : "#{$sel}#{$var}";
		}

		// handle separators :
		@if $var == '%-' and $i < length($pattern) {
			$index : $i + 1;
			$value : nth($pattern, $index);
			@if $value != '%state' and $value != '%count' and $value != '%-' and $value != '%prefix' {
				$sel : "#{$sel}#{$gridle-class-separator}";
			}
			@if $value == '%state' and $state {
				$sel : "#{$sel}#{$gridle-class-separator}";
			}
			@if $value == '%count' and $count {
				$sel : "#{$sel}#{$gridle-class-separator}";
			}
		}

		// update i :
		$i : $i + 1;
	}

	// return generated class :
	@return $sel;
}


/**
 * Get the media query for a particular state, or with, etc...
 *
 * @param 	Mixed 		$state-or-min-width 		The state name of the min with
 * @param 	Mixed 		$max-width 			The max width if first param is a min width
 * @return 	String 						The media query string without the @media
 */
@function _get_media_query_for_state(
	$state-or-min-width : null,
	$max-width : null
) {

	// get the index of state :
	$state : _gridle_get_state($state-or-min-width);

	// if there's an idx, the state requested is a registered one :
	@if $state {

		// get vars :
		$name : map-get($state, name);
		$min-width : map-get($state, min-width);
		$max-width : map-get($state, max-width);
		$classes : map-get($state, classes);
		$query : map-get($state, query);

		// check if exist :
		@if $name {

			// check if query exist :
			@if $query {
				@return $query;
			} @else {

				// write media query :
				@if $min-width and $max-width {
					@return "screen and (min-width: #{$min-width}) and (max-width: #{$max-width})";
				} @else if $min-width == null and $max-width {
					@return "screen and (max-width: #{$max-width})";
				} @else if $min-width and $max-width == null {
					@return "screen and (min-width: #{$min-width})";
				} @else {
					@return false;
				}
			}
		} @else {
			@return "not working";
		}
	} @else if $state-or-min-width == 'print' or $state-or-min-width == print {
		@return "only print";
	} @else if $state-or-min-width == 'tv' or $state-or-min-width == tv {
		@return "only tv";
	} @else if $state-or-min-width == 'portrait' or $state-or-min-width == portrait {
		@return "only screen and (orientation: portrait)";
	} @else if $state-or-min-width == 'landscape' or $state-or-min-width == landscape {
		@return "only screen and (orientation: landscape)";
	} @else if $state-or-min-width == 'retina' or $state-or-min-width == retina {
		@return "only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)";
	} @else {
		// check for min and max width :
		@if $state-or-min-width and $max-width {
			@return "screen and (min-width: #{$state-or-min-width}) and (max-width: #{$max-width})";
		} @else if $state-or-min-width and $max-width == null {
			@return "screen and (min-width: #{$state-or-min-width})";
		} @else if $state-or-min-width == null and $max-width {
			@return "screen and (max-width: #{$max-width})";
		} @else {
			@return null;
		}
	}
}


/**
 * Get states count
 * 
 * @return 	int 	The number of states defined
 */
@function _gridle_get_states_count() {
	@return length($_gridle_states) / length($_gridle_states_vars_pattern);
}