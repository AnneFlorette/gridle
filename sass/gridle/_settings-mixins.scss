// |------------------------------------------------------
// |------------------------------------------------------
// | Settings mixins
// |------------------------------------------------------
// |------------------------------------------------------

//
// Setup
//
@mixin gridle_setup(
	$settings : ()
) {
	$_gridle-settings : map-merge((
		name : default,
		min-width : null,
		max-width : null,
		query : null,
		classes : true,
		context : 12,
		gutter-width : 20px,
		direction : ltr,
		name-multiplicator : 1,
		debug : false,
		debug-show-class-names : true,
		class-separator : "-",
		states-classes : false,
		generate-push-classes : true,
		generate-pull-classes : true,
		generate-prefix-classes : true,
		generate-suffix-classes : true,
		generate-helpers-classes : true
	), $settings) !global;

	// register default state :
	@include gridle_register_state(default, $_gridle-settings);

	// set current state to default
	$_gridle_current_state : $_gridle-settings !global;
	$_gridle_current_stateName : default !global;

}

//
// Register a state
//
@mixin gridle_register_state(
	$name,
	$settings
) {
	// settings :
	$settings : map-merge($_gridle-settings, $settings);

	// set name :
	$settings : map-set($settings, name, $name);

	// add state in maps :
	$_gridle_states : map-set($_gridle_states, $name, $settings) !global;

	// add rules if gutter is different
	$gutter-width : map-get($settings, gutter-width);
	@if $gutter-width != map-get($_gridle-settings, gutter-width) {
		@debug("different gutters for #{$name}");
		@include gridle_apply_css_for(grid, (
			padding-left : $gutter-width / 2,
			padding-right : $gutter-width / 2,
		), $name);
		@include gridle_apply_css_for(flex-grid, (
			padding-left : $gutter-width / 2,
			padding-right : $gutter-width / 2,
		), $name);
	}

	// add rules if direction is different
	$direction : map-get($settings, direction);
	@if $direction != map-get($_gridle-settings, direction) {
		$float : left;
		@if $direction == rtl {
			$float : right;
		}
		@include gridle_apply_css_for(grid, (
			direction : $direction,
			float : $float
		), $name);
	}
}


//
//  Register a clear each class
//
@mixin gridle_register_clear_each(
	$count,
	$clearWhat
) {
	// create the clear map :
	$classMap : (
		clearEach : $count,
		clearWhat : $clearWhat
	);

	// append to map :
	$_gridle_clear_classes : map-set($_gridle_clear_classes, $count, $classMap) !global;
}


//
// Register a special class
//
@mixin gridle_register_column(
	$name,
	$columns,
	$context
) {
	// create a column :
	$col : _gridle_create_column($name, $columns, $context);

	// add column in maps :
	$_gridle_columns : map-set($_gridle_columns, $name, $col) !global;
}


//
// Set a classmap
//
@mixin gridle_set_classname_map(
	$for,
	$pattern
) {
	// set the classmap
	$_gridle-names-patterns : map-set($_gridle-names-patterns, $for, $pattern) !global;
}


//
// Extend a gridle class
//
@mixin gridle_extend_base_class(
	$for,
	$extend,
	$statesNames : default
) {
	// get the map for the passed mixin "category"
	$forMap : map-get($_gridle_extend_base_classes, $for);

	// create the map if not exist
	@if $forMap == null { $forMap : (); }

	// if $states is all
	@if $statesNames == all {
		$statesNames : gridle_get_registered_states_names();
	}

	// loop on each states to register an extend map
	@each $stateName in $statesNames {

		// check if has a map for the state
		$forStateMap : map-get($forMap, $stateName);
		@if $forStateMap == null {
			$forStateMap : ();
		}
		
		// merge map
		$forStateMap : map-merge($forStateMap, $extend);

		// set the new state map into forMap
		$forMap : map-set($forMap, $stateName, $forStateMap);

		// set the map in the gridle global variable
		$_gridle_extend_base_classes : map-set($_gridle_extend_base_classes, $for, $forMap) !global;

	}
}


//
// Apply css for
//
@mixin gridle_apply_css_for(
	$for,
	$extend,
	$statesNames : default
) {
	// get the map for the passed mixin "category"
	$forMap : map-get($_gridle_apply_css_for, $for);

	// create the map if not exist
	@if $forMap == null { $forMap : (); }

	// if $states is all
	@if $statesNames == all {
		$statesNames : gridle_get_registered_states_names();
	}

	// loop on each states to register an extend map
	@each $stateName in $statesNames {

		// check if has a map for the state
		$forStateMap : map-get($forMap, $stateName);
		@if $forStateMap == null {
			$forStateMap : ();
		}

		// merge map
		$forStateMap : map-merge($forStateMap, $extend);

		// set the new state map into forMap
		$forMap : map-set($forMap, $stateName, $forStateMap);

		// set the map in the gridle global variable
		$_gridle_apply_css_for : map-set($_gridle_apply_css_for, $for, $forMap) !global;

	}
}


//
// Register default states
//
@mixin gridle_register_default_states() {
	@include gridle_register_state(mobile, (
		max-width : 480px
	));
	@include gridle_register_state(tablet, (
		min-width : 481px,
		max-width : 1024px
	));
}


//
// Register default mobile first states :
//
@mixin gridle_register_default_mobile_first_states() {
	@include gridle_register_state(xs, (
		max-width : 768px
	));
	@include gridle_register_state(sm, (
		min-width : 768px
	));
	@include gridle_register_state(md, (
		min-width : 992px
	));
	@include gridle_register_state(lg, (
		min-width : 1200px
	));
}


//
// Set the debug device (not used for now)
// 
// @param 	String 		$state 		The state to update
// @para m 	String 		$device 	The device to use (iphone, etc...)
//
@mixin gridle_set_debug_device(
	$state : default,
	$device : null
) {

	// check params :
	@if $state and $device {
		// set the state device :
		$_gridle_states_debug_devices : append($_gridle_states_debug_devices, unquote("\"#{$state}\" : \"#{$device}\""), comma);
	}

}