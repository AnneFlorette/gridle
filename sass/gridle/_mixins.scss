// |------------------------------------------------------
// |------------------------------------------------------
// | Mixins
// |------------------------------------------------------
// |------------------------------------------------------


//
// Init
// called by _gridle_call mixin multiple times
//
@mixin gridle_init() {
	@if $_gridle_inited == false {
		$_gridle_inited : true !global;
		@each $stateName, $state in $_gridle_states {
			$classes : gridle_get_state_var(classes, $state);
			@if $classes {
				@at-root {
					$q : _gridle_get_media_query($state);
					@if $q {
						@media #{$q} {
							@include _gridle_init_common_silent_classes($state);
						}
					} @else {
						@include _gridle_init_common_silent_classes($state);
					}
				}
			}
		}
	}
}


//
// Call an api mixin by checking if need to loop over states
// or not.
// This mixin set also the global variable $_content_arg_state
// in order to use it in api mixin to refer to the current
// active state
//			
@mixin _gridle_call(
	$states : default,
	$for : null
) {
	// init if needed
	@include gridle_init();

	// check if need media query :
	@if type-of($states) == map {
		@include gridle_state($states) {
			$_content_arg_state : $states !global;
			@content;

			@if $for {
				@include _gridle_extend($for);
				@include _gridle_apply_css_for($for);
			}
		}
	} @elseif $states {
		@each $s in $states {
			// extend common css for grid and state
			@include gridle_state($s) {
				$_content_arg_state : $s !global;
				@content;

				@if $for {
					@include _gridle_extend($for);
					@include _gridle_apply_css_for($for);
				}
			}
		}
	} @else {
		$_content_arg_state : $_gridle_current_state !global;
		@content;

		@if $for {
			@include _gridle_extend($for);
			@include _gridle_apply_css_for($for);
		}
	}
}


//
// Init silent classes
//
@mixin _gridle_common_silent_class_name(
	$for,
	$stateName : default
) {
	%#{$stateName}-#{$for} {
		// inject content
		@content;
		// extend common class by the registered css
		@include _gridle_extend_common_class($for, $stateName);
	}
	@at-root (without: media) {
		%at-root-#{$stateName}-#{$for} {
			// inject content
			@content;
			// extend common class by the registered css
			@include _gridle_extend_common_class($for, $stateName);
		}
	}
}
@mixin _gridle_init_common_silent_classes(
	$state : default
) {
	// get state name
	$stateName : gridle_get_state_var(name, $state);

	// container
	@include _gridle_common_silent_class_name(container, $stateName) {
		@include _gridle_common_container($state);
	}

	// flex grid
	@include _gridle_common_silent_class_name(flex-grid, $stateName) {
		@include _gridle_common_flex_grid($state);
	}

	// flex order
	@include _gridle_common_silent_class_name(flex-order, $stateName) {
		@include _gridle_common_flex_order($state);
	}

	// flex reverse
	@include _gridle_common_silent_class_name(flex-reverse, $stateName) {
		@include _gridle_common_flex_reverse($state);
	}

	// flex grow
	@include _gridle_common_silent_class_name(flex-grow, $stateName) {
		@include _gridle_common_flex_grow($state);
	}

	// flex row
	@include _gridle_common_silent_class_name(flex-row, $stateName) {
		@include _gridle_common_flex_row($state);
	}

	// flex col
	@include _gridle_common_silent_class_name(flex-col, $stateName) {
		@include _gridle_common_flex_col($state);
	}

	// flex align
	@include _gridle_common_silent_class_name(flex-align, $stateName) {
		@include _gridle_common_flex_align($state);
	}

	// flex distribution
	@include _gridle_common_silent_class_name(flex-distribution, $stateName) {
		@include _gridle_common_flex_distribution($state);
	}

	// parent
	@include _gridle_common_silent_class_name(parent, $stateName) {
		@include _gridle_common_parent($state);
	}

	// grid
	@include _gridle_common_silent_class_name(grid, $stateName) {
		@include _gridle_common_grid($state);
	}

	// push
	@include _gridle_common_silent_class_name(push, $stateName) {
		@include _gridle_common_push($state);
	}

	// pull
	@include _gridle_common_silent_class_name(pull, $stateName) {
		@include _gridle_common_pull($state);
	}

	// prefix
	@include _gridle_common_silent_class_name(prefix, $stateName) {
		@include _gridle_common_prefix($state);
	}

	
	// suffix
	@include _gridle_common_silent_class_name(suffix, $stateName) {
		@include _gridle_common_suffix($state);
	}

	// clear-each
	@include _gridle_common_silent_class_name(clear-each, $stateName) {
		@include _gridle_common_clear_each($state);
	}

	// centered
	@include _gridle_common_silent_class_name(centered, $stateName) {
		@include _gridle_common_centered($state);
	}

	// align
	@include _gridle_common_silent_class_name(align, $stateName) {
		@include _gridle_common_align($state);
	}

	// hide
	@include _gridle_common_silent_class_name(hide, $stateName) {
		@include _gridle_common_hide($state);
	}

	// not-visible
	@include _gridle_common_silent_class_name(not-visible, $stateName) {
		@include _gridle_common_not_visible($state);
	}

	// show
	@include _gridle_common_silent_class_name(show, $stateName) {
		@include _gridle_common_show($state);
	}

	// show-inline
	@include _gridle_common_silent_class_name(show-inline, $stateName) {
		@include _gridle_common_show_inline($state);
	}

	// visible
	@include _gridle_common_silent_class_name(visible, $stateName) {
		@include _gridle_common_visible($state);
	}

	// float
	@include _gridle_common_silent_class_name(float, $stateName) {
		@include _gridle_common_float($state);
	}

	// clear
	@include _gridle_common_silent_class_name(clear, $stateName) {
		@include _gridle_common_clear($state);
	}

	// no-gutter
	@include _gridle_common_silent_class_name(no-gutter, $stateName) {
		@include _gridle_common_no_gutter($state);
	}

	// gutter
	@include _gridle_common_silent_class_name(gutter, $stateName) {
		@include _gridle_common_gutter($state);
	}
}


//
// Gridle state
//
// @param 	string|map|list 	$states 		A list of states, a state name or a state map
// @param 	boolean 			$has-parent 	Mostly always true, mean that the mixin is used in a css selector and not in css root level
//
@mixin _gridle_state(
	$state : default,
	$has-parent : true,
	$track-current-state : false
) {

	// variables :
	$states-classes : gridle_get_state_var(states-classes, $state);
	$stateName : gridle_get_state_var(name, $state);

	// check if need to tack the current state
	@if $track-current-state {
		// save current state
		$_gridle_current_state : $state !global;
		$_gridle_current_stateName : $stateName !global;
	}

	// check if is a state :
	@if ($states-classes)
		and $stateName {
		// html class :
		@at-root (without: media) {
			@if $has-parent {
				.state-#{$stateName} & { 
					@content;
				}
			} @else {
				.state-#{$stateName} {
					@content;
				}
			}
		}
	}

	// get the media query :
	$q : _gridle_get_media_query($state);

	// make the media query if a query exist :
	@if $q {
		@media #{$q} {
			@content;
		}
	} @else {
		@content;
	}

	// reset current state to default
	@if $track-current-state {
		$_gridle_current_state : $_gridle_settings !global;
		$_gridle_current_stateName : default !global;
	}
}


//
// Transform map to css
//
@mixin _gridle_map_2_css(
	$map
) {
	@each $key, $value in $map {
		@if type-of($value) == map {
			&#{$key} {
				@each $k, $v in $value {
					#{$k}:#{$v};
				}
			}
		} @else {
			#{$key}:#{$value};
		}
	}
}

//
// Extend common class
//
@mixin _gridle_extend_common_class(
	$what,
	$state : default
) {
	// extend
	$name : gridle_get_state_var(name, $state);
	$extend : gridle_get_extend_class_map($what, $name);
	@if $extend != null {
		@include _gridle_map_2_css($extend);
	}
}


//
// Extend
//
@mixin _gridle_extend(
	$for
) {
	// check if we need the state classes
	$states-classes : gridle_get_state_var(states-classes, $_gridle_current_state);

	// extend the "at-root" version for the .state-{stateName} classes
	@if $states-classes and str-index(#{&}, unquote(".state-#{$_gridle_current_stateName}")) {
		@at-root (without: media) {
			@extend %at-root-#{$_gridle_current_stateName}-#{$for} !optional;
		}
	} @else {
		// extend using the current state name set in each gridle_state call
		@extend %#{$_gridle_current_stateName}-#{$for} !optional;
	}
}


//
// Apply the registered css for a certain type (grid, push, etc...)
// in each states
//
@mixin _gridle_apply_css_for(
	$for
) {
	// loop on each states
	$rulesByStates : map-get($_gridle_apply_css_for, $for);
	@each $stateName, $rules in $rulesByStates {
		@include _gridle_state($stateName) {
			@include _gridle_map_2_css($rules);
		}
	}
}