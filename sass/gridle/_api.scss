//
// Gridle state
//
// @param 	string|map|list 	$states 		A list of states, a state name or a state map
// @param 	boolean 			$has-parent 	Mostly always true, mean that the mixin is used in a css selector and not in css root level
//
@mixin gridle_state(
	$states,
	$has-parent : true
) {

	// check if is a min-max witdh query (compatibility layer)
	@if type-of($states) == number and type-of($has-parent) == number {

		// get a new state from settings passed
		$state : gridle_get_state((
			min-width : $states,
			max-width : $has-parent
		));

		// make a query
		@include gridle_state($state) {
			@content;
		}

	} @elseif type-of($states) == list
		or type-of($states) == string {

		// loop on each states :
		@each $state in $states
		{
			// make sure we have the state object
			$state : gridle_get_state($state);

			// make gridle state
			@include _gridle_state($state, $has-parent, true) {
				@content;
			}
		}

	} @elseif type-of($states) == map {

		// get a state from the passed one
		$state : gridle_get_state($states);

		// make gridle state
		@include _gridle_state($state, $has-parent, true) {
			@content;
		}
	}
}


//
// Gridle use state
// This mixin will only set the current state to use and NOT print out any media query
//
@mixin gridle_use_state(
	$state
) {
	// get the state
	$state : gridle_get_state($state);
	$stateName : gridle_get_state_var(name, $state);

	// save the current state
	$savedState : $_gridle_current_state;
	$savedStateName : $_gridle_current_stateName;

	// set the current state
	$_gridle_current_state : $state !global;
	$_gridle_current_stateName : $stateName !global;

	// generate content
	@content;

	// reset the state
	$_gridle_current_state : $savedState !global;
	$_gridle_current_stateName : $savedStateName !global;
}


//
// Gridle selector
//
@mixin gridle_selector(
	$for,
	$states : null
) {
	#{gridle_selector($for, $states)} {
		@content;
	}
}


//
// Helper to apply multiple config for a certain state with one mixin
//
@mixin gridle_set(
	$settings,
	$state : default
) {
	// init if needed
	@include gridle_init();
	// wrap in media query
	@include gridle_state($state) {
		@include _gridle_set($settings);
	}
}
@mixin _gridle_set(
	$settings
) {
	// loop on each settings
	@each $settingName, $settingValue in $settings
	{
		$sn : unquote("#{$settingName}");
		$sv : $settingValue;

		// check if setting name is a state :
		@if gridle_has_state($sn) {
			// process the state
			@include gridle_set($sv, $sn);
		} @else {
			@if $sn == container {
				@include gridle_container();
			} @else if $sn == flex-grid {
				@include gridle_flex_grid($sv);
			} @else if $sn == flex-order {
				@include gridle_flex_order($sv);
			} @else if $sn == flex-row {
				@include gridle_flex_row($sv);
			} @else if $sn == flex-col {
				@include gridle_flex_col($sv);
			} @else if $sn == flex-grow {
				@include gridle_flex_grow();
			} @else if $sn == flex-adapt {
				@include gridle_flex_adapt();
			} @else if $sn == flex-align {
				@include gridle_flex_align($sv);
			} @else if $sn == grid {
				@include gridle($sv);
			} @else if $sn == push {
				@include gridle_push($sv);
			} @else if $sn == pull {
				@include gridle_pull($sv);
			} @else if $sn == prefix {
				@include gridle_prefix($sv);
			} @else if $sn == suffix {
				@include gridle_suffix($sv);
			} @else if $sn == pull {
				@include gridle_pull($sv);
			} @else if $sn == clear-each {
				@include gridle_clear_each(nth($sv,1), nth($sv,2));
			} @else if $sn == centered {
				@include gridle_centered();
			} @else if $sn == row {
				@include gridle_row();
			} @else if $sn == align {
				@include gridle_align($sv);
			} @else if $sn == hide {
				@if $sv == true {
					@include gridle_hide();
				} @else {
					@include gridle_show();
				}
			} @else if $sn == show {
				@if $sv == true {
					@include gridle_show();
				} @else {
					@include gridle_hide();
				}
			} @else if $sn == visible {
				@if $sv == true {
					@include gridle_visible();
				} @else {
					@include gridle_not_visible();
				}
			} @else if $sn == not-visible {
				@if $sv == true {
					@include gridle_not_visible();
				} @else {
					@include gridle_visible();
				}
			} @else if $sn == show-inline {
				@if $sv == true {
					@include gridle_show_inline();
				} @else {
					@include gridle_hide();
				}
			} @else if $sn == float {
				@include gridle_float($sv);
			} @else if $sn == clear {
				@include gridle_clear($sv);
			} @else if $sn == no-gutter {
				@include gridle_no_gutter($sv);
			} @else if $sn == gutter or $sn == gutter-width {
				@include gridle_gutter($sv);
			} @else {
				// we do nothing
			}
		}
	}
}


//
// Debug
//
@mixin gridle_debug(
	$what,
	$output : shell
) {
	@if $gridle-debug {
		@if $output == shell {
			@debug(inspect($what));
		} @else {
			@if type-of($what) == map {
				@include gridle_debug_map($what);
			} @else {
				@_ {
					#{type-of($what)} : inspect($what);
				}
			}
		}
	}
}


//
// Debug a map
//
@mixin gridle_debug_map($map, $name : '') {
	@at-root {
		@_ #{$name} {
			@each $key, $value in $map {
				@if type-of($value) == map {
					@include gridle_debug_map($value, $key);
				} @else {
					#{$key}: inspect($value);
				}
			}
		}
	}
}


//
// Container
//
@mixin gridle_container(
) {
	@include _gridle_call(container) {
	}
}


//
// Row
//
@mixin gridle_row(
) {
	@include _gridle_call(row) {
		padding-left: 0 !important;
		padding-right: 0 !important;
	}
}


//
// Row table
//
@mixin gridle_row_table(
) {
	@include _gridle_call(row-table) {
		padding-left: 0 !important;
		padding-right: 0 !important;
		> * {
			display: table-cell;
			float: none;
			vertical-align: top;
		}
	}
}


//
// Row table break
//
@mixin gridle_row_table_break(
) {
	@include _gridle_call(row-table-break) {
	}
}


//
// flex row
//
@mixin gridle_flex_row(
	$reverse : false
) {
	@include _gridle_call(flex-row) {
		@if $reverse {
			@include flex-direction(row-reverse);
		} @else {
			@include flex-direction(row);
		}
		padding-left: 0 !important;
		padding-right: 0 !important;
	}
}


//
// flex col
//
@mixin gridle_flex_col(
	$reverse : false
) {
	@include _gridle_call(flex-col) {
		@if $reverse {
			@include flex-direction(column-reverse);
		} @else {
			@include flex-direction(column);
		}
		padding-left: 0 !important;
		padding-right: 0 !important;
	}
}


//
// flex grid
//
@mixin gridle_flex_grid(
	$columns,
	$context : null
) {
	@include _gridle_call(flex-grid) {
		// vars :
		$name : gridle_get_state_var(name);
		@if type-of($context) != number {
			$context : gridle_get_state_var(context);
		}
		$name-multiplicator : gridle_get_state_var(name-multiplicator);
		
		// manage columns
		@if type-of($columns) != number and map-has-key($_gridle_columns, $columns) {
			// the columns is a saved one, get the context and column value
			$column : map-get($_gridle_columns, $columns);
			$context : map-get($column, context);
			$columns : map-get($column, columns);
		} @else if type-of($columns) == number {
			$columns : $columns / $name-multiplicator;
		} @else {
			@error "the column #{$columns} does not exist...";
		}

		// vars :
		$width : percentage(1 / $context * $columns);

		// set value :
		@include flex-basis($width);
		max-width : $width;
	}
}


//
// flex order
//
@mixin gridle_flex_order(
	$position
) {
	@include _gridle_call(flex-order) {
		@include order($position);
	}
}


//
// flex adapt
//
@mixin gridle_flex_adapt(
) {
	@include _gridle_call(flex-adapt) {
	}
}
@mixin _gridle_flex_adapt(
) {
}


//
// flex grow
//
@mixin gridle_flex_grow(
) {
	@include _gridle_call(flex-grow) {
	}
}


//
// flex align
//
@mixin gridle_flex_align(
	$align : left
) {
	@include _gridle_call(flex-align) {
		@each $al in $align {
			@if $al == around {
				@include justify-content(space-around);
			} @else if $al == between {
				@include justify-content(space-between);
			} @else if $al == left {
				@include justify-content(flex-start);
			} @else if $al == center {
				@include justify-content(center);
			} @else if $al == right {
				@include justify-content(flex-end);
			} @else if $al == top {
				@include align-items(flex-start);
			} @else if $al == middle {
				@include align-items(center);
			} @else if $al == bottom {
				@include align-items(flex-end);
			}
		}
	}
}


//
// Grid
//
@mixin gridle(
	$columns,
	$context : null
) {
	@include _gridle_call(grid) {
		// vars :
		$name : gridle_get_state_var(name);
		@if type-of($context) != number {
			$context : gridle_get_state_var(context);
		}
		$direction : gridle_get_state_var(direction);
		$name-multiplicator : gridle_get_state_var(name-multiplicator);
		
		// manage columns
		@if type-of($columns) != number and map-has-key($_gridle_columns, $columns) {
			// the columns is a saved one, get the context and column value
			$column : map-get($_gridle_columns, $columns);
			$context : map-get($column, context);
			$columns : map-get($column, columns);
		} @else if type-of($columns) == number {
			$columns : $columns / $name-multiplicator;
		} @else {
			@error "the column #{$columns} does not exist...";
		}

		// vars :
		$width : percentage(1 / $context * $columns);

		// set value :
		width:$width;

		@if $columns == $context {
			display: inline-block;
		}
	}
}


//
// Grid table
//
@mixin gridle_grid_table(
) {
	@include _gridle_call(grid-table) {
		display: table-cell;
		float: none;
		vertical-align: top;
	}
}


//
// grid adapt
//
@mixin gridle_adapt(
) {
	@include _gridle_call(adapt) {
	}
}


//
// grid grow
//
@mixin gridle_grow(
) {
	@include _gridle_call(grow) {
	}
}


//
// Push
//
@mixin gridle_push(
	$columns,
	$context : null
) {
	@include _gridle_call(push) {
		// variables :
		@if type-of($context) != number {
			$context : gridle_get_state_var(context);
		}
		$direction : gridle_get_state_var(direction);
		$name-multiplicator : gridle_get_state_var(name-multiplicator);

		// vars :
		$width : percentage(1 / $context) * ($columns / $name-multiplicator);
		@if $direction == rtl { $width : $width*-1; }
		left:$width;
	}
}


//
// Pull
//
@mixin gridle_pull(
	$columns,
	$context : null
) {
	@include _gridle_call(pull) {
		// variables :
		@if type-of($context) != number {
			$context : gridle_get_state_var(context);
		}
		$direction : gridle_get_state_var(direction);
		$name-multiplicator : gridle_get_state_var(name-multiplicator);
		
		// vars :
		$width : percentage(1 / $context) * ($columns / $name-multiplicator);
		@if $direction == rtl { $width : $width*-1; }
		right:$width;
	}
}


//
// Prefix
//
@mixin gridle_prefix(
	$columns,
	$context : null
) {
	@include _gridle_call(prefix) {
		// vars :
		@if type-of($context) != number {
			$context : gridle_get_state_var(context);
		}
		$direction : gridle_get_state_var(direction);
		$name-multiplicator : gridle_get_state_var(name-multiplicator);
		
		// vars :
		$width : percentage(1 / $context) * ($columns / $name-multiplicator);

		// set value :
		@if $direction == rtl { margin-right:$width; }
		@else { margin-left:$width; }
	}
}


//
// Suffix
//
@mixin gridle_suffix(
	$columns,
	$context : null
) {
	@include _gridle_call(suffix) {
		// vars :
		@if type-of($context) != number {
			$context : gridle_get_state_var(context);
		}
		$direction : gridle_get_state_var(direction);
		$name-multiplicator : gridle_get_state_var(name-multiplicator);
		
		// vars :
		$width : percentage(1 / $context) * ($columns / $name-multiplicator);
		
		// set value :
		@if $direction == rtl { margin-left:$width; }
		@else { margin-right:$width; }
	}
}
@mixin _gridle_suffix(
	$columns,
	$state : default,
	$context : null
) {
	
}


//
// Grid background
//
@mixin gridle_grid_background(
	$states : null
) {
	@include _gridle_call(background) {
		// variables :
		$context : gridle_get_state_var(context);

		position:relative;
		z-index:9999;
		&:before {
			content:'';
			position:absolute;
			top:0; left:0;
			width:100%; height:100% !important;
			// vars :
			$width : percentage(1 / $context);
			background: linear-gradient(to right, rgba(0,0,0,0) 50% , rgba(0,0,0,.02) 50%); // Standard syntax
			background-size:($width*2) 100%;
		}
	}
}


//
// Clear each
//
@mixin gridle_clear_each(
	$clearEach,
	$clearWhat : both
) {
	@include _gridle_call(clear-each) {
		> *:nth-child(#{$clearEach}n+1) {
			clear : $clearWhat;
		}
	}
}


//
// Centered
//
@mixin gridle_centered(
) {
	@include _gridle_call(centered) {
	}
}


//
// Align :
//
@mixin gridle_align(
	$align : middle
) {
	@include _gridle_call(align) {
		// need to change the way grids items are layed out
		@if $align == top or $align == middle or $align == bottom {
			font-size:0;
			clear:both;

			> * {
				float:none !important;
				vertical-align:$align;
				font-size:1rem;
			}

		} @else {
			@if $align == left {
				text-align: left;
			} @else if $align == center {
				text-align: center;
			} @else if $align == right {
				text-align: right;
			}
			// restore text align of the grid items
			> * {
				text-align: left;
			}
		}
	}
}


//
// Hide
//
@mixin gridle_hide(
) {
	@include _gridle_call(hide) {
		display:none;
	}
}


//
// Not visible on
//
// @param 	String 	$media 	What to hide (one of the 3 state classes name)
//
@mixin gridle_not_visible(
) {
	@include _gridle_call(not-visible) {
		visibility:hidden;
	}
}


//
// Show on
//
// @param 	String 	$media 	What to hide (one of the 3 state classes name)
//
@mixin gridle_show(
) {
	@include _gridle_call(show) {
		display:block;
	}
}


//
// Show inline
//
// @param 	String 		$state 		The state name
//
@mixin gridle_show_inline(
) {
	@include _gridle_call(show-inline) {
		display:inline-block;
	}
}


//
// Visible on :
// @param 	String 	$media 	On what state
//
@mixin gridle_visible(
) {
	@include _gridle_call(visible) {
		visibility:visible;
	}
}


//
// Float :
//
@mixin gridle_float(
	$float-direction : left
) {
	@include _gridle_call(float) {
		float:#{$float-direction};
	}
}


//
// Gridle clear :
//
// @param 	String 	$clear-direction 	The direction to clear
// @param 	String 	$state 				The state
//
@mixin gridle_clear(
	$clear-direction : both
) {
	@include _gridle_call(clear) {
		clear:#{$clear-direction};
	}
}


//
// Gridle no gutter :
//
// @param 	String 	$side 				The side to clear
// @param 	String 	$state 				The state
//
@mixin gridle_no_gutter(
	$side : top right bottom left
) {
	@include _gridle_call(no-gutter) {
		@each $s in $side {
			padding-#{$s} : 0;
		}
	}
}


//
// Gridle gutter :
//
// @param 	String 	$side 				The side to clear
// @param 	String 	$state 				The state
//
@mixin gridle_gutter(
	$side-or-size : top right bottom left
) {
	@include _gridle_call(gutter) {
		
		// get a gutter map
		$gutters : _gridle_forge_gutters_map($side-or-size);

		// check that we have a gutter map
		@each $side, $value in $gutters {
			@if $value > 0 {
				padding-#{$side} : $value;
			}
		}

	}
}