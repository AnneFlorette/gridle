// |------------------------------------------------------
// |------------------------------------------------------
// | Generate mixins
// |------------------------------------------------------
// |------------------------------------------------------


//
// Generate a custom class for all the states
//
// @param 	list 	$pattern 		The name pattern of the class
// @param 	list 	$statesNames 		The states names to generate
//
@mixin gridle_generate_custom_class(
	$pattern,
	$statesNames : null
) {
	// manage states to generate :
	$states : ();
	@if $statesNames == null {
		// loop on each states to generate names list :
		@each $stateName, $state in $_gridle_states {
			$states : append($states, $stateName);
		}
	} @else {
		$states : $statesNames;
	}

	// loop on each states :
	@each $stateName in $states
	{
		// manage statename :
		@if type-of($stateName) != string {
			$stateName : map-get($stateName, name);
		}

		// classes :
		$classes : gridle_get_state_var(classes, $stateName);

		// genrate the classname :
		@if $classes
		{
			@include gridle_state($stateName, false) {
				#{_gridle_classname($pattern, $stateName)} {
					@content;
				}
			}
		}
	}
}


//
// Generate all helpers classes
//
@mixin _gridle_generate_helper_classes (
	$state : null,
	$package : null
) {
	// vars
	$flex : gridle_get_state_var(flex, $state);

	// helpers :
	@if _gridle_need_to_generate(all float helpers, $package) {
		#{_gridle_classname(float, $state, left)} {
			@include gridle_float(left);
		}
		#{_gridle_classname(float, $state, right)} {
			@include gridle_float(right);
		}
	}

	@if _gridle_need_to_generate(all clear helpers, $package) {
		#{_gridle_classname(clear, $state)} {
			@include gridle_clear(both);
		}
		#{_gridle_classname(clear, $state, left)} {
			@include gridle_clear(left);
		}
		#{_gridle_classname(clear, $state, right)} {
			@include gridle_clear(right);
		}
	}

	@if _gridle_need_to_generate(all no-gutter helpers, $package) {
		#{_gridle_classname(no-gutter, $state)} {
			@include gridle_no_gutter();
		}
		#{_gridle_classname(no-gutter, $state, left)} {
			@include gridle_no_gutter(left);
		}
		#{_gridle_classname(no-gutter, $state, right)} {
			@include gridle_no_gutter(right);
		}
		#{_gridle_classname(no-gutter, $state, top)} {
			@include gridle_no_gutter(top);
		}
		#{_gridle_classname(no-gutter, $state, bottom)} {
			@include gridle_no_gutter(bottom);
		}
	}

	@if _gridle_need_to_generate(all gutter helpers, $package) {
		#{_gridle_classname(gutter, $state)} {
			@include gridle_gutter(top right bottom left);
		}
		#{_gridle_classname(gutter, $state, left)} {
			@include gridle_gutter(left);
		}
		#{_gridle_classname(gutter, $state, right)} {
			@include gridle_gutter(right);
		}
		#{_gridle_classname(gutter, $state, top)} {
			@include gridle_gutter(top);
		}
		#{_gridle_classname(gutter, $state, bottom)} {
			@include gridle_gutter(bottom);
		}
	}

	@if _gridle_need_to_generate(all auto-height helpers, $package) {
		#{_gridle_classname(auto-height, $state)} {
			height:inherit;
		}
	}

	@if _gridle_need_to_generate(all centered helpers, $package) {
		#{_gridle_classname(centered, $state)} {
			@include gridle_centered();
		}
	}

	@if _gridle_need_to_generate(all container default, $package) {
		#{_gridle_classname(container, $state)} {
			@include gridle_container();
		}
	}

	@if _gridle_need_to_generate(all row default, $package) {
		#{_gridle_classname(row, $state)} {
			@include gridle_row(false);
		}
		#{_gridle_classname(row, $state, reverse)} {
			@include gridle_row(true);
		}
	}

	@if _gridle_need_to_generate(all col default, $package) {
		#{_gridle_classname(col, $state)} {
			@include gridle_col(false);
		}
		#{_gridle_classname(col, $state, reverse)} {
			@include gridle_col(true);
		}
	}

	@if _gridle_need_to_generate(all grid-table default, $package) {
		#{_gridle_classname(grid-table, $state)} {
			@include gridle_grid_table();
		}
	}

	@if _gridle_need_to_generate(all adapt default, $package) {
		#{_gridle_classname(adapt, $state)} {
			@include gridle_adapt();
		}
	}

	@if _gridle_need_to_generate(all grow default, $package) {
		#{_gridle_classname(grow, $state)} {
			@include gridle_grow();
		}
	}

	@if _gridle_need_to_generate(all align helpers, $package) {
		#{_gridle_classname(align, $state, left)} {
			@include gridle_align(left);
		}
		#{_gridle_classname(align, $state, center)} {
			@include gridle_align(center);
		}
		#{_gridle_classname(align, $state, right)} {
			@include gridle_align(right);
		}
		#{_gridle_classname(align, $state, middle)} {
			@include gridle_align(middle);
		}
		#{_gridle_classname(align, $state, top)} {
			@include gridle_align(top);
		}
		#{_gridle_classname(align, $state, bottom)} {
			@include gridle_align(bottom);
		}
		@if $flex {
			#{_gridle_classname(align, $state, around)} {
				@include gridle_align(around);
			}
			#{_gridle_classname(align, $state, between)} {
				@include gridle_align(between);
			}
		}
	}

	//
	// Visible, hide, etc...
	//
	@if _gridle_need_to_generate(all hide helpers, $package) {
		#{_gridle_classname(hide, $state)} {
			@include gridle_hide();
		}
	}

	@if _gridle_need_to_generate(all not-visible helpers, $package) {
		#{_gridle_classname(not-visible, $state)} {
			@include gridle_not_visible();
		}
	}

	@if _gridle_need_to_generate(all show helpers, $package) {
		#{_gridle_classname(show, $state)} {
			@include gridle_show();
		}
	}

	@if _gridle_need_to_generate(all show-inline helpers, $package) {
		#{_gridle_classname(show-inline, $state)} {
			@include gridle_show_inline();
		}
	}

	@if _gridle_need_to_generate(all visible helpers, $package) {
		#{_gridle_classname(visible, $state)} {
			@include gridle_visible();
		}
	}

	//
	// Clear each class :
	//
	@if _gridle_need_to_generate(all clear-each helpers, $package) {
		@each $clearName, $clearMap in $_gridle_clear_classes {
			// get count :
			$clearCount : map-get($clearMap, clearEach);
			// what to clear :
			$clearWhat : map-get($clearMap, clearWhat);
			// generate the class :
			#{_gridle_classname(clear-each, $state, $clearCount)} {
				@include gridle_clear_each($clearCount, $clearWhat);
			}
		}
	}
}


//
// Generate json settings
//
@mixin gridle_generate_json_settings() {

	// settings content :
	$gridle-settings-states : "{";

	// generate all classes for differents media queries :
	$statesCount : length($_gridle_states);
	$i : 0;
	@each $stateName, $state in $_gridle_states {
	
		$name : $stateName;

		$gridle-settings-states : "#{$gridle-settings-states} \"#{$name}\":{";
	
		@each $varName, $var in $state {

			$value : null;
			@if $varName == "query" {
				$value : gridle_get_media_query($stateName);
			} @else {
				$value : map-get($state,$varName);
			}

			@if $value == null {
				$gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : null,";
			} @elseif type-of($value) == bool {
				$gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : #{$value},";
			} @elseif type-of($value) == map {
				$gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : {";
				@each $vn, $vv in $value {
					$gridle-settings-states : "#{$gridle-settings-states} \"#{$vn}\" : \"#{$vv}\","
				}
				$gridle-settings-states : "#{$gridle-settings-states} \"_\" : true";
				$gridle-settings-states : "#{$gridle-settings-states} },";
			} @else {
				$gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : \"#{$value}\",";
			}
		}

		$gridle-settings-states : "#{$gridle-settings-states} \"_\" : true";

		@if $i >= $statesCount - 1 {
			$gridle-settings-states : "#{$gridle-settings-states} }";
		} @else {
			$gridle-settings-states : "#{$gridle-settings-states} },";
		}
	
		// update i :
		$i : $i + 1;

	}

	 // generate settings json :
	$gridle-settings-states : "#{$gridle-settings-states}}";
	$gridle-settings : "{";
	$gridle-settings : "#{$gridle-settings} \"version\" : \"#{$_gridle-version}\"";
	
	// states :
	$gridle-settings : "#{$gridle-settings}, \"states\" : #{$gridle-settings-states}";
	
	// settings :
	$gridle-settings : "#{$gridle-settings} }";
	#gridle-settings {
		content : $gridle-settings;
	}
}


//
// Generate classes
//
@mixin gridle_generate_classes(
	$states : null, // null mean all states here...
	$package : (default, helpers),
	$scope : null
) {

	// check if a scope exist
	@if $scope {
		// wrapp grid into scope
		.#{$scope} {
			@include _gridle_generate_classes($states, $package, true);
		}
	} @else {
		// generate classes
		@include _gridle_generate_classes($states, $package, false);
	}
}
$_gridle_generateOnlyOnce : true; // keep track of generate once classes
@mixin _gridle_generate_classes(
	$states : null, // null mean all states here...
	$package : (default, helpers),
	$has-parent : false
) {	

	// set that we are in generate phase (that can be used anywhere)
	$_gridle_is_in_generate_phase : true !global;

	// if no states are provided, mean that we want all states
	@if $states == null {
		$states : gridle_get_registered_states_names();
	}

	// generate these classes only once
	@if $_gridle_generateOnlyOnce
	{

		// update status
		$_gridle_generateOnlyOnce : false;

		// | ------------------------
		// | Windows 8 fix
		// | ------------------------
		
		// Windows 8 fix for snap mode
		@media screen and (max-width: 400px) {
			@-ms-viewport { width: device-width; }
		}

		// | ------------------------
		// | JSON Settings
		// | ------------------------
	 
		// generate json settings
		@if $gridle-generate-json-settings
		{
			@include gridle_generate_json_settings();
		}

	}

	// loop on each states to generate all the classes
	@each $stateName in $states {

		// get the actual state
		$state : gridle_get_state($stateName);

		// debug
		@debug("Generate classes for state #{$stateName}");

		// scope all the classes in a media query
		@include gridle_state($state, false) {

			// setup vars :
			$classes : gridle_get_state_var(classes, $state);

			// stop here if no classes wanted
			@if $classes {

				// generate all classes for columns
				$i : 0;
				@each $columnName, $column in gridle_get_columns($state) {

					// variables
					$columnsCount : map-get($column, columns);
					$columnsContext : map-get($column, context);
					$columnsNameMultiplicator : map-get($column, name-multiplicator);

					// extend context in state (for columns)
					$extendedState : map-merge($state, (
						context : $columnsContext,
						name-multiplicator : $columnsNameMultiplicator // inject the name multiplicator here getted from column to handle custom registered columns
					));

					// classes
					@if _gridle_need_to_generate(all grid default, $package) {
						#{_gridle_classname(grid, $stateName, $columnName)} {
							@include gridle($columnsCount, $columnsContext);
						}
					}
					@if _gridle_need_to_generate(all push default, $package) {
						#{_gridle_classname(push, $stateName, $columnName)} {
							@include gridle_push($columnsCount, $columnsContext);
						}
					}
					@if _gridle_need_to_generate(all pull default, $package) {
						#{_gridle_classname(pull, $stateName, $columnName)} {
							@include gridle_pull($columnsCount, $columnsContext);
						}
					}
					@if _gridle_need_to_generate(all prefix default, $package) {
						#{_gridle_classname(prefix, $stateName, $columnName)} {
							@include gridle_prefix($columnsCount, $columnsContext);
						}
					}
					@if _gridle_need_to_generate(all suffix default, $package) {
						#{_gridle_classname(suffix, $stateName, $columnName)} {
							@include gridle_suffix($columnsCount, $columnsContext);
						}   
					}
					@if _gridle_need_to_generate(all order default, $package) {
						#{_gridle_classname(order, $stateName, first)} {
							@include gridle_order(-1);
						} 
						#{_gridle_classname(order, $stateName, $i)} {
							@include gridle_order($i);
						}  
						#{_gridle_classname(order, $stateName, last)} {
							@include gridle_order(9999);
						} 
					}
					// up $i
					$i : $i + 1;
				}

				// media queries helpers classes
				@include _gridle_generate_helper_classes($stateName, $package);
			}
		}
	}

	// apply css for states of each elements
	$fors : $_gridle-names-patterns;
	@each $map in $_gridle_apply_css_for {
		@each $stateName, $fors in $map {
			@include _gridle_state($stateName, false) {
				@each $f, $rules in $fors {
					@if map-get($fors, $f) {
						@include gridle_selector($f, null) {
							@include _gridle_map_2_css($rules);
						}
					}
				}
			}
		}
	}

	@each $stateName, $state in gridle_get_registered_states() {
		$gutter-left : gridle_get_state_var(gutter-left, $state);
		$gutter-right : gridle_get_state_var(gutter-right, $state);
		@include _gridle_state($stateName, false) {
			[class*="#{str-slice(_gridle_classname(grid),2)}"] > [class*="#{str-slice(_gridle_classname(row),2)}"],
			[class*="#{str-slice(_gridle_classname(grid),2)}"] > [class*="#{str-slice(_gridle_classname(col),2)}"] {
				margin-left: -#{$gutter-left};
				margin-right: -#{$gutter-right};
			}
		}
	}

	// reset the variable that track if we are in generate phase or not
	$_gridle_is_in_generate_phase : false !global;
}