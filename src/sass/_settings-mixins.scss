// |------------------------------------------------------
// |------------------------------------------------------
// | Settings mixins
// |------------------------------------------------------
// |------------------------------------------------------

//
// Setup
//
@mixin g-setup(
	$settings : ()
) {
	// prepare state
	$settings : _g-prepare-state-settings($settings);

	// extend default settings
	$_gridle-settings : map-merge((
		name : default,
		min-width : null,
		max-width : null,
		query : null,
		classes : true,
		context : 12,
		column-width : null,
		gutter-width : 20px,
		gutter-height : 0,
		gutter-top : 0,
		gutter-right : 10px,
		gutter-bottom : 0,
		gutter-left : 10px,
		direction : ltr,
		dir-attribute : false,
		name-multiplicator : 1,
		states-classes : false,
		classes-prefix : null
	), $settings) !global;

	// register default state :
	@include g-register-state(default, $_gridle-settings);

	// set current state to default
	$_g-current-state : $_gridle-settings !global;
	$_g-current-stateName : default !global;
}

//
// Register a state
//
@mixin g-register-state(
	$name,
	$settings : ()
) {
	// prepare state
	$settings : _g-prepare-state-settings($settings);

	// settings :
	$settings : map-merge($_gridle-settings, $settings);

	// set name :
	$settings : map-set($settings, name, $name);

	// gutter sizes :
	$gutter-top : map-get($settings, gutter-top);
	$gutter-right : map-get($settings, gutter-right);
	$gutter-bottom : map-get($settings, gutter-bottom);
	$gutter-left : map-get($settings, gutter-left);

	// add state in maps :
	$_g-states : map-set($_g-states, $name, $settings) !global;

	// add rules if gutter is different
	@if $gutter-top != map-get($_gridle-settings, gutter-top)
		or $gutter-right != map-get($_gridle-settings, gutter-right)
		or $gutter-bottom != map-get($_gridle-settings, gutter-bottom)
		or $gutter-left != map-get($_gridle-settings, gutter-left) {
		$gutters : _g-forge-gutters-map(top right bottom left, $name);
		@include g-apply-css-for(grid grid-grow grid-adapt, (
			g-gutter : top right bottom left
		), $name);
	}

	// add rules if direction is different
	$direction : map-get($settings, direction);
	@if $direction != map-get($_gridle-settings, direction) {
		$float : left;
		@if $direction == rtl {
			$float : right;
		}
		@include g-apply-css-for(grid, (
			direction : $direction,
			float : $float
		), $name);
	}

	/**
	 * @name 	#{g-get-state-var(name, $name)} State
	 * Here's the settings for the **#{g-get-state-var(name, $name)}** state.
	 * @styleguide 	Gridle / States
	 * @display 	gridle-settings
	 * @gridle-name 	#{g-get-state-var(name, $name)}
	 * @gridle-min-width 	#{g-get-state-var(min-width, $name)}
	 * @gridle-max-width 	#{g-get-state-var(max-width, $name)}
	 * @gridle-query 	#{g-get-state-var(query, $name)}
	 * @gridle-classes 	#{g-get-state-var(classes, $name)}
	 * @gridle-context 	#{g-get-state-var(context, $name)}
	 * @gridle-gutter-width 	#{g-get-state-var(gutter-width, $name)}
	 * @gridle-gutter-height 	#{g-get-state-var(gutter-height, $name)}
	 * @gridle-gutter-top 	#{g-get-state-var(gutter-top, $name)}
	 * @gridle-gutter-right 	#{g-get-state-var(gutter-right, $name)}
	 * @gridle-gutter-bottom 	#{g-get-state-var(gutter-bottom, $name)}
	 * @gridle-gutter-left 	#{g-get-state-var(gutter-left, $name)}
	 * @gridle-direction 	#{g-get-state-var(direction, $name)}
	 * @gridle-dir-attribute 	#{g-get-state-var(dir-attribute, $name)}
	 * @gridle-name-multiplicator 	#{g-get-state-var(name-multiplicator, $name)}
	 * @gridle-states-classes 	#{g-get-state-var(states-classes, $name)}
	 * @gridle-classes-prefix 	#{g-get-state-var(classes-prefix, $name)}
	 */
}


//
//  Register a clear each class
//
@mixin g-register-clear-each(
	$count,
	$clearWhat
) {
	// create the clear map :
	$classMap : (
		clearEach : $count,
		clearWhat : $clearWhat
	);

	// append to map :
	$_g-clear_classes : map-set($_g-clear_classes, $count, $classMap) !global;
}


//
// Register a special class
//
@mixin g-register-column(
	$name,
	$columns,
	$context
) {
	// create a column :
	$col : _g-create-column($name, $columns, $context);

	// add column in maps :
	$_g-columns : map-set($_g-columns, $name, $col) !global;
}


//
// Set a classmap
//
@mixin g-set-classname-map(
	$for,
	$pattern
) {
	// get the map
	$map : map-get($_gridle-packages, $for);
	// set the new classname
	$map : map-set($map, classname, $pattern);
	// set the classmap
	$_gridle-packages : map-set($_gridle-packages, $for, $map) !global;
}


//
// Set a generic selector
//
@mixin g-set-generic-selector(
	$for,
	$selector
) {
	// get the map
	$map : map-get($_gridle-packages, $for);
	// set the new classname
	$map : map-set($map, generic-selector, $selector);
	// set the classmap
	$_gridle-packages : map-set($_gridle-packages, $for, $map) !global;
}


//
// Extend a gridle class
//
// map format :
// (
// 	grid : (
// 		mobile : (
// 			padding : 10px,
// 			float : left
// 		),
// 		tablet : (
// 			padding : 10px
// 		)
// 	),
// 	flex-grid : (
// 		mobile : (
// 			padding : 10px
// 		)
// 	)
// )
//
// @mixin g-extend-base-class(
// 	$for,
// 	$extend,
// 	$statesNames : null
// ) {
// 	// if $states is all
// 	@if $statesNames == null {
// 		$statesNames : g-get-states-names();
// 	}

// 	// allow multiple "$for"
// 	@each $f in $for {

// 		// get the map for the passed mixin "category"
// 		$forMap : map-get($_g-extend_base_classes, $f);

// 		// create the map if not exist
// 		@if $forMap == null { $forMap : (); }

// 		// loop on each states to register an extend map
// 		@each $stateName in $statesNames {

// 			// check if has a map for the state
// 			$forStateMap : map-get($forMap, $stateName);
// 			@if $forStateMap == null {
// 				$forStateMap : ();
// 			}

// 			// merge map
// 			$forStateMap : map-merge($forStateMap, $extend);

// 			// set the new state map into forMap
// 			$forMap : map-set($forMap, $stateName, $forStateMap);

// 			// set the map in the gridle global variable
// 			$_g-extend_base_classes : map-set($_g-extend_base_classes, $f, $forMap) !global;

// 		}

// 	}
// }
@mixin g-extend-base-class(
	$for,
	$extend,
	$statesNames : null
) {
	// if $states is all
	@if $statesNames == null {
		$statesNames : g-get-states-names();
	}

	// allow multiple "$for"
	@each $stateName in $statesNames {

		// get the map for the passed mixin "category"
		$stateMap : map-get($_g-extend_base_classes, $stateName);

		// create the map if not exist
		@if $stateMap == null { $stateMap : (); }

		// loop on each states to register an extend map
		@each $f in $for {

			// check if has a map for the state
			$forStateMap : map-get($stateMap, $f);
			@if $forStateMap == null {
				$forStateMap : ();
			}

			// merge map
			$forStateMap : map-merge($forStateMap, $extend);

			// set the new state map into forMap
			$stateMap : map-set($stateMap, $f, $forStateMap);

			// set the map in the gridle global variable
			$_g-extend_base_classes : map-set($_g-extend_base_classes, $stateName, $stateMap) !global;
		}
	}
}

//
// Apply css for
//
// map format :
// (
// 	(
// 		grid : (
// 			mobile : (
// 				padding : 0,
// 				margin : 0
// 			),
// 			tablet : (
// 				padding : 0
// 			)
// 		)
// 	),
// 	(
// 		etc...
// 	)
// )
// @mixin g-apply-css-for(
// 	$for,
// 	$extend,
// 	$statesNames : null
// ) {

// 	// if statesNames is null, mean that it's all the states
// 	@if $statesNames == null {
// 		$statesNames : g-get-states-names();
// 	}

// 	// allow multiple "$for"
// 	@each $f in $for {

// 		// get the map for the passed mixin "category"
// 		$stateMap : ();

// 		// loop on each states to register an extend map
// 		@each $stateName in $statesNames {
// 			// add the css
// 			$stateMap : map-set($stateMap, $stateName, $extend);
// 		}

// 		// set in map
// 		$forMap : map-set((), $f, $stateMap);

// 		// set the map in the gridle global variable
// 		$_g-apply-css-for : append($_g-apply-css-for, $forMap) !global;

// 	}
// }
@mixin g-apply-css-for(
	$for,
	$extend,
	$statesNames : null
) {

	// if statesNames is null, mean that it's all the states
	@if $statesNames == null {
		$statesNames : g-get-states-names();
	}

	// allow multiple "$for"
	@each $stateName in $statesNames {

		// get the map for the passed mixin "category"
		$forMap : ();

		// loop on each states to register an extend map
		@each $f in $for {
			// add the css
			$forMap : map-set($forMap, $f, $extend);
			// $stateMap : map-set($stateMap, $stateName, $extend);
		}

		// set in map
		$statesMap : map-set((), $stateName, $forMap);

		// set the map in the gridle global variable
		$_g-apply-css-for : append($_g-apply-css-for, $statesMap) !global;
	}
}


//
// Register default states
//
@mixin g-register-default-states() {
	@include g-register-state(mobile, (
		max-width : 480px
	));
	@include g-register-state(tablet, (
		min-width : 481px,
		max-width : 1024px
	));
}


//
// Register default mobile first states :
//
@mixin g-register-default-mobile-first-states() {
	@include g-register-state(xs, (
		max-width : 750px
	));
	@include g-register-state(sm, (
		min-width : 750px
	));
	@include g-register-state(md, (
		min-width : 970px
	));
	@include g-register-state(lg, (
		min-width : 1170px
	));
}
